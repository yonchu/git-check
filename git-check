#!/bin/bash
#
#  Check git status and check if git remote repositories is updated.
#
#    Usage:
#      git-check [-s|-r|-w] [-f <Repositories list file>] [Directory ...]
#
#    Options:
#      -s : Check git status.
#      -r : Check if git remote repositories is updated.
#      -w N : Indent width.(Default: 4)
#      -f [File] : The file in which Wrote the path to repositories.

if ! type git > /dev/null 2>&1; then
    echo 'Error: Git is not installed' 2>&1
    exit 1
fi


# This script name.
PROG=$(basename "$0")

INDENT_WIDTH=4

### Usage.
USAGE=`cat << __EOF__
Usage:
  $PROG [-s|-r|-w] [-f <Repositories list file>] [Directory ...]
Options:
  -s : Check status.
  -r : Check remote updated.
  -w N : Indent width.(Default: 4)
  -f [File] : The file in which Wrote the path to repositories.
__EOF__
`

## Common
exit_usage() {
    echo "$USAGE" 1>&2
    exit 1
}
get_head_branch () {
    local head_branch=$(git symbolic-ref -q --short HEAD)
    if [ -z "$head_branch" ]; then
        local prehash=$(git rev-parse --short HEAD)
        echo "Not on any branch : prehash=$prehash"
        return 1
    fi
    echo "$head_branch"
}
# $1 : Branch.
get_remote_name () {
    local branch=$1
    # The remote name of this branch (e.g. origin).
    local remote_name=$(git config branch."${branch}".remote)
    if [ -z "$remote_name" ]; then
        echo 'No remote repository'
        return 1
    fi
    echo "$remote_name"
}
is_git_dir() {
    if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" != 'true' ]; then
        echo "Not git directory." 1>&2
        return 1
    fi
    return 0
}
# $1 : The directory path.
cd_git_toplevel() {
    cd "$1"
    is_git_dir 2> /dev/null || return 1
    cd "$(git rev-parse --show-toplevel)"
}
# $1 : Indent level.
print_indent() {
    local level=${1:-0}
    if [ "$level" -eq 0 ]; then
        return
    fi
    local i
    for i in $(seq 1 $(($level * $INDENT_WIDTH))); do
            echo -n " "
    done
}
# $1 : The executing command.
# $2 : Indent level.
exec_cmd_in_submodules() {
    local cmd=$1
    local indent_level=${2:-1}
    local -a submodule_dirs
    IFS=$'\n' submodule_dirs=($(git submodule 2> /dev/null | sed 's/^ *//g' | cut -d ' ' -f 2 | sed 's/(.*)$//'))
    if [ -z "$submodule_dirs" ]; then
        return 0
    fi
    for sub_dir in "${submodule_dirs[@]}"; do
        (
            cd "$sub_dir" || continue
            "$cmd" "$sub_dir" "$indent_level"
        )
    done
}
# $1 : The executing command.
# $@ : Directories.
exec_cmd_in_dir() {
    local cmd=$1
    shift
    local dir
    for dir in "$@"; do
        is_dir "$dir" || continue
        (
            cd_git_toplevel "$dir" || continue
            "$cmd" "$dir"
        )
    done
}
# $1 : The directory path.
is_dir() {
    local dir=$1
    if [ ! -e "$dir" ]; then
        echo -e "\033[0;31mDirectory not found!! : $dir\033[0;39m"
        return 1
    elif [ ! -d "$dir" ]; then
        return 1
    fi
    return 0
}


### For check_remote_in_dir.
# $1 : The directory path.
# $2 : Indent level.
check_remote_in_dir() {
    local dir=$1
    local indent_level=${2:-0}

    local status
    local url

    local branch
    local remote_branch

    if [ ! -e .git ]; then
        status='not init'
    else
        branch=$(get_head_branch)
        if [ $? -eq 0 ]; then
            remote_name=$(get_remote_name "$branch")
            if [ $? -eq 0 ]; then
                local remote_show=$(git remote show "$remote_name")
                status=$(echo "$remote_show" \
                    | grep "^ *$branch *pushes" | sed 's/.*(\(.*\)).*/\1/')
                url=$(echo "$remote_show" | grep '^ *Push' | sed 's/^.*URL: \(.*\)$/\1/')
                remote_branch=$(echo "$remote_show" \
                    | grep "^ *$branch *pushes" | sed 's/.*pushes to \(.*\) (.*)/\1/' | tr -d ' ')
            else
                status=$remote_name
            fi
        else
            status=$branch
            branch=''
        fi
    fi
    if [ "$status" != "up to date" ]; then
        status="\033[0;31m$status\033[0;39m"
    fi
    local branch_info=''
    if [ -n "$branch" ]; then
        branch_info="($branch -> $remote_branch)"
    fi

    local update_info="($status) [${dir%/}]$branch_info${url:+ URL: $url}"

    print_indent "$indent_level"
    echo -e "$update_info"

    exec_cmd_in_submodules "check_remote_in_dir" "$(($indent_level + 1))"
}


### For check_status.
# $1 : The directory path.
# $2 : Indent level.
check_status_in_dir() {
    local dir=$1
    local indent_level=${2:-0}
    local -a output

    if [ ! -e .git ]; then
        echo -e "[$dir] \033[0;31mError: not init\033[0;39m"
        return 1
    fi

    output+=("[$dir] ($(get_head_branch))")
    status=$(git status -s)
    if [ -n "$status" ]; then
        IFS=$'\n' output+=($(echo "$status" | sed  's/\(.*\) \(.*\)/\\033[0;31m\1\\033[0;39m \2/g'))
    fi
    for line in "${output[@]}"; do
        print_indent "$indent_level"
        echo -e "$line"
    done
    exec_cmd_in_submodules "check_status_in_dir" "$(($indent_level + 1))"
}


### Main ###
main() {
    ## Parse options.
    local opt_s
    local opt_r
    local opt_f
    local file
    local option
    while getopts srf:w: option; do
        case "$option" in
            s)
                # Check git status.
                opt_s='true'
                ;;
            r)
                # Check git remote.
                opt_r='true'
                ;;
            f)
                # Check repositories list file.
                opt_f='true'
                file=$OPTARG
                ;;
            w)
                # Check indent width.
                INDENT_WIDTH=$OPTARG
                ;;
            :|\?)
                exit_usage
                ;;
        esac
    done
    shift $((${OPTIND} - 1))

    ## Execute main process.
    if [ -n "$opt_f" ]; then
        # Check repositories list file.
        echo "Read file \"${file}\"..."
        echo '--------- ---------- ----------'
        local -a lines
        IFS=$'\n' lines=($(cat "${file}"))

        local line

        if [ -z "$opt_s" -a -z "$opt_r" -o -n "$opt_s" -a -n "$opt_r" ]; then
            echo '### Check status:'
            for line in "${lines[@]}"; do
                echo "## $line"
                line=$(echo "$line" | sed "s%^~%$HOME%")
                exec_cmd_in_dir 'check_status_in_dir' $line
                echo
            done
            echo '--------- ---------- ----------'
            echo '### Check remote:'
            for line in "${lines[@]}"; do
                echo "## $line"
                line=$(echo "$line" | sed "s%^~%$HOME%")
                exec_cmd_in_dir 'check_remote_in_dir' $line
                echo
            done
        elif [ -n "$opt_s" ]; then
            echo '### Check status:'
            for line in "${lines[@]}"; do
                echo "## $line"
                line=$(echo "$line" | sed "s%^~%$HOME%")
                exec_cmd_in_dir 'check_status_in_dir' $line
                echo
            done
        elif [ -n "$opt_r" ]; then
            echo '### Check remote:'
            for line in "${lines[@]}"; do
                echo "## $line"
                line=$(echo "$line" | sed "s%^~%$HOME%")
                exec_cmd_in_dir 'check_remote_in_dir' $line
                echo
            done
        fi
    else
        if [ $# -eq 0 ]; then
            # Check current directory.
            is_git_dir || return 1
            set '.'
        fi
    fi

    if [ $# -gt 0 ]; then
        if [ -z "$opt_s" -a -z "$opt_r" -o -n "$opt_s" -a -n "$opt_r" ]; then
            echo '### Check status:'
            exec_cmd_in_dir 'check_status_in_dir' "$@"
            echo
            echo '### Check remote:'
            exec_cmd_in_dir 'check_remote_in_dir' "$@"
        elif [ -n "$opt_s" ]; then
            echo '### Check status:'
            exec_cmd_in_dir 'check_status_in_dir' "$@"
        elif [ -n "$opt_r" ]; then
            echo '### Check remote:'
            exec_cmd_in_dir 'check_remote_in_dir' "$@"
        fi
    fi
}

main "$@"

